<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ‘ï¸ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯ - Ù…Ø´Ø§Ù‡Ø¯Ø© Ø§Ù„Ø¨Ø« Ø§Ù„Ù…Ø¨Ø§Ø´Ø±</title>
    <style>
        :root {
            --primary: #7209b7;
            --success: #4cc9f0;
            --warning: #f8961e;
            --dark: #10002b;
            --light: #f8f9fa;
            --gray: #6c757d;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Cairo', Tahoma, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            padding: 25px 0;
            margin-bottom: 30px;
            border-bottom: 3px solid var(--primary);
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        h1 {
            color: #fff;
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #7209b7, #4361ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 5px 15px rgba(114, 9, 183, 0.3);
        }
        
        .subtitle {
            color: #a1cae2;
            font-size: 1.2rem;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            margin-bottom: 40px;
        }
        
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .join-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid rgba(114, 9, 183, 0.2);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .section-title {
            color: #4cc9f0;
            font-size: 1.5rem;
            margin-bottom: 25px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(76, 201, 240, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .input-group {
            margin-bottom: 25px;
        }
        
        label {
            display: block;
            margin-bottom: 10px;
            color: #a1cae2;
            font-weight: 600;
            font-size: 1.1rem;
        }
        
        input {
            width: 100%;
            padding: 15px;
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(114, 9, 183, 0.3);
            border-radius: 12px;
            color: white;
            font-size: 1.1rem;
            transition: all 0.3s ease;
        }
        
        input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(114, 9, 183, 0.2);
            background: rgba(255, 255, 255, 0.12);
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 30px 0;
        }
        
        .btn {
            padding: 18px 25px;
            border: none;
            border-radius: 12px;
            font-weight: 700;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #7209b7 0%, #4361ee 100%);
            color: white;
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #f8961e 0%, #f3722c 100%);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .video-container {
            background: #000;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            position: relative;
            min-height: 500px;
        }
        
        video {
            width: 100%;
            height: auto;
            max-height: 700px;
            display: block;
            background: #111;
        }
        
        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            padding: 30px;
            z-index: 10;
        }
        
        .overlay-icon {
            font-size: 5rem;
            margin-bottom: 20px;
            color: #7209b7;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .status-indicator {
            padding: 15px 25px;
            border-radius: 12px;
            margin: 20px 0;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .status-connected {
            background: rgba(76, 201, 240, 0.15);
            color: #4cc9f0;
            border: 2px solid rgba(76, 201, 240, 0.3);
        }
        
        .status-disconnected {
            background: rgba(248, 150, 30, 0.15);
            color: #f8961e;
            border: 2px solid rgba(248, 150, 30, 0.3);
        }
        
        .status-connecting {
            background: rgba(114, 9, 183, 0.15);
            color: #7209b7;
            border: 2px solid rgba(114, 9, 183, 0.3);
        }
        
        .info-box {
            background: rgba(114, 9, 183, 0.1);
            border: 1px solid rgba(114, 9, 183, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-top: 25px;
        }
        
        .info-box h3 {
            color: #a1cae2;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .info-box ol {
            padding-right: 20px;
            line-height: 1.8;
        }
        
        .info-box li {
            margin-bottom: 10px;
            color: #cbd5e1;
        }
        
        .stats-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 20;
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
        }
        
        .stat-value {
            font-weight: 700;
            color: #4cc9f0;
        }
        
        .controls-bar {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 20;
        }
        
        .control-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 10px 15px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-btn:hover {
            background: rgba(114, 9, 183, 0.6);
            transform: translateY(-2px);
        }
        
        footer {
            text-align: center;
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: #6c757d;
            font-size: 0.9rem;
        }
        
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 25px;
            background: var(--primary);
            color: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .quality-selector {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .quality-btn {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #a1cae2;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .quality-btn.active {
            background: rgba(114, 9, 183, 0.3);
            border-color: #7209b7;
            color: white;
        }
        
        .quality-btn:hover {
            background: rgba(114, 9, 183, 0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ‘ï¸ Ù…Ø´Ø§Ù‡Ø¯Ø© Ø§Ù„Ø¨Ø« Ø§Ù„Ù…Ø¨Ø§Ø´Ø±</h1>
            <p class="subtitle">Ø´Ø§Ù‡Ø¯ Ø§Ù„Ø¨Ø« Ø§Ù„Ù…Ø¨Ø§Ø´Ø± ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ù…Ø¹ ØªØ£Ø®ÙŠØ± Ø£Ù‚Ù„ Ù…Ù† Ù†ØµÙ Ø«Ø§Ù†ÙŠØ©</p>
        </header>
        
        <div class="main-content">
            <div class="join-panel">
                <div class="section-title">
                    <span>ğŸ”— Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ù„Ù„Ø¨Ø«</span>
                </div>
                
                <div class="input-group">
                    <label for="viewerRoomId">ğŸ”‘ Ù…Ø¹Ø±Ù Ø§Ù„Ø¨Ø« (Room ID)</label>
                    <input type="text" id="viewerRoomId" placeholder="Ø£Ø¯Ø®Ù„ Ù…Ø¹Ø±Ù Ø§Ù„Ø¨Ø« Ø§Ù„Ø°ÙŠ Ø£Ø¹Ø·Ø§Ùƒ Ø¥ÙŠØ§Ù‡ Ø§Ù„Ù…Ø¯ÙŠØ¹">
                    <small style="color: #6c757d; display: block; margin-top: 8px;">Ø§Ù†Ø³Ø® Ø§Ù„Ù…Ø¹Ø±Ù Ù…Ù† Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ø¯ÙŠØ¹ Ø£Ùˆ Ø£Ø¯Ø®Ù„Ù‡ ÙŠØ¯ÙˆÙŠØ§Ù‹</small>
                </div>
                
                <div class="quality-selector">
                    <div class="quality-btn active" data-quality="auto">ØªÙ„Ù‚Ø§Ø¦ÙŠ</div>
                    <div class="quality-btn" data-quality="720p">720p</div>
                    <div class="quality-btn" data-quality="480p">480p</div>
                </div>
                
                <div class="button-group">
                    <button id="joinBtn" class="btn btn-primary">
                        <span>ğŸš€</span>
                        <span>Ø§Ù†Ø¶Ù… Ù„Ù„Ø¨Ø«</span>
                    </button>
                    <button id="leaveBtn" class="btn btn-warning" disabled>
                        <span>ğŸ‘‹</span>
                        <span>Ù…ØºØ§Ø¯Ø±Ø© Ø§Ù„Ø¨Ø«</span>
                    </button>
                </div>
                
                <div id="status" class="status-indicator status-disconnected">
                    <span>ğŸ”´</span>
                    <span>Ù„Ù… ØªÙ†Ø¶Ù… Ø¨Ø¹Ø¯ - Ø£Ø¯Ø®Ù„ Ù…Ø¹Ø±Ù Ø§Ù„Ø¨Ø« ÙˆØ§Ø¶ØºØ· "Ø§Ù†Ø¶Ù… Ù„Ù„Ø¨Ø«"</span>
                </div>
                
                <div class="info-box">
                    <h3>
                        <span>ğŸ’¡</span>
                        <span>ÙƒÙŠÙÙŠØ© Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø©:</span>
                    </h3>
                    <ol>
                        <li>Ø§Ù†Ø³Ø® Ù…Ø¹Ø±Ù Ø§Ù„Ø¨Ø« Ù…Ù† Ø§Ù„Ù…Ø¯ÙŠØ¹ (Ù…Ø«Ù„: my-live-123)</li>
                        <li>Ø£Ø¯Ø®Ù„ Ø§Ù„Ù…Ø¹Ø±Ù ÙÙŠ Ø§Ù„Ø­Ù‚Ù„ Ø£Ø¹Ù„Ø§Ù‡</li>
                        <li>Ø§Ø¶ØºØ· "Ø§Ù†Ø¶Ù… Ù„Ù„Ø¨Ø«"</li>
                        <li>Ø§Ù†ØªØ¸Ø± Ø§ØªØµØ§Ù„ Ø§Ù„Ø¨Ø« (Ù‚Ø¯ ÙŠØ³ØªØºØ±Ù‚ 2-5 Ø«ÙˆØ§Ù†ÙŠ)</li>
                        <li>Ø§Ø³ØªÙ…ØªØ¹ Ø¨Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø© ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ!</li>
                    </ol>
                </div>
            </div>
            
            <div class="video-container">
                <div id="videoOverlay" class="video-overlay">
                    <div class="overlay-icon">ğŸ“º</div>
                    <h2 style="margin-bottom: 15px; font-size: 2rem;">ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø¨Ø«</h2>
                    <p style="color: #a1cae2; max-width: 500px; margin-bottom: 25px;">
                        Ø£Ø¯Ø®Ù„ Ù…Ø¹Ø±Ù Ø§Ù„Ø¨Ø« ÙÙŠ Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© ÙˆØ§Ù†Ø¶Ù… Ù„Ù…Ø´Ø§Ù‡Ø¯Ø© Ø§Ù„Ø¨Ø« Ø§Ù„Ù…Ø¨Ø§Ø´Ø±
                    </p>
                    <div style="color: #6c757d; font-size: 0.9rem;">
                        âš¡ ØªØ£Ø®ÙŠØ± Ø£Ù‚Ù„ Ù…Ù† 500ms Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… ØªÙ‚Ù†ÙŠØ© WebRTC
                    </div>
                </div>
                
                <div class="controls-bar" id="controlsBar" style="display: none;">
                    <div class="control-btn" id="fullscreenBtn">
                        <span>â›¶</span>
                        <span>Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø©</span>
                    </div>
                    <div class="control-btn" id="volumeBtn">
                        <span>ğŸ”Š</span>
                        <span>Ø§Ù„ØµÙˆØª</span>
                    </div>
                </div>
                
                <div class="stats-bar" id="statsBar" style="display: none;">
                    <div class="stat-item">
                        <span>ğŸ“¡</span>
                        <span>Ø­Ø§Ù„Ø©:</span>
                        <span id="streamStatus" class="stat-value">--</span>
                    </div>
                    <div class="stat-item">
                        <span>â±ï¸</span>
                        <span>Ø§Ù„Ù…Ø¯Ø©:</span>
                        <span id="watchTime" class="stat-value">00:00</span>
                    </div>
                    <div class="stat-item">
                        <span>ğŸ¥</span>
                        <span>Ø§Ù„Ù…Ø¯ÙŠØ¹:</span>
                        <span id="broadcasterId" class="stat-value">--</span>
                    </div>
                </div>
                
                <video id="remoteVideo" autoplay playsinline></video>
            </div>
        </div>
        
        <div class="toast" id="toast"></div>
        
        <footer>
            <p>Â© 2025 Ù…Ù†ØµØ© Ø§Ù„Ø¨Ø« Ø§Ù„Ù…Ø¨Ø§Ø´Ø± | ØªØ¬Ø±Ø¨Ø© Ù…Ø´Ø§Ù‡Ø¯Ø© ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ | Ø§Ù„Ø³ÙŠØ±ÙØ±: cripanyt.onrender.com</p>
            <p style="font-size: 0.8rem; margin-top: 8px; color: #6c757d;">
                ÙŠØ¯Ø¹Ù… Ø§Ù„Ù‡ÙˆØ§ØªÙ ÙˆØ§Ù„Ø£Ø¬Ù‡Ø²Ø© Ø§Ù„Ù„ÙˆØ­ÙŠØ© ÙˆØ§Ù„Ø­ÙˆØ§Ø³ÙŠØ¨ | Ù„Ø§ Ø­Ø§Ø¬Ø© Ù„ØªØ«Ø¨ÙŠØª Ø£ÙŠ Ø¨Ø±Ù†Ø§Ù…Ø¬
            </p>
        </footer>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            SIGNALING_SERVER: 'wss://cripanyt.onrender.com',
            STUN_SERVERS: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ],
            RECONNECT_DELAYS: [1000, 2000, 5000, 10000, 15000],
            CONNECTION_TIMEOUT: 10000
        };

        // DOM Elements
        const viewerRoomId = document.getElementById('viewerRoomId');
        const joinBtn = document.getElementById('joinBtn');
        const leaveBtn = document.getElementById('leaveBtn');
        const statusDiv = document.getElementById('status');
        const remoteVideo = document.getElementById('remoteVideo');
        const videoOverlay = document.getElementById('videoOverlay');
        const controlsBar = document.getElementById('controlsBar');
        const statsBar = document.getElementById('statsBar');
        const streamStatus = document.getElementById('streamStatus');
        const watchTime = document.getElementById('watchTime');
        const broadcasterId = document.getElementById('broadcasterId');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const volumeBtn = document.getElementById('volumeBtn');
        const qualityBtns = document.querySelectorAll('.quality-btn');
        const toast = document.getElementById('toast');

        // Application State
        let state = {
            socket: null,
            peerConnection: null,
            currentRoomId: '',
            isConnected: false,
            reconnectAttempt: 0,
            watchStartTime: null,
            watchInterval: null,
            streamQuality: 'auto',
            volume: 1,
            isFullscreen: false,
            connectionTimeout: null
        };

        // Show toast message
        function showToast(message, type = 'info') {
            toast.textContent = message;
            toast.style.background = type === 'success' ? '#4cc9f0' : 
                                  type === 'error' ? '#f8961e' : '#7209b7';
            toast.style.display = 'block';
            
            setTimeout(() => {
                toast.style.display = 'none';
            }, 3000);
        }

        // Update status display
        function updateStatus(message, type = 'disconnected') {
            const icons = {
                connected: 'ğŸŸ¢',
                connecting: 'ğŸŸ¡',
                disconnected: 'ğŸ”´'
            };
            
            statusDiv.innerHTML = `<span>${icons[type] || 'âšª'}</span><span>${message}</span>`;
            statusDiv.className = `status-indicator status-${type}`;
            streamStatus.textContent = type === 'connected' ? 'Ù…Ø¨Ø§Ø´Ø±' : 
                                     type === 'connecting' ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„' : 'Ù…ØªÙˆÙ‚Ù';
        }

        // Get room ID from URL parameters
        function getRoomFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const roomParam = urlParams.get('room');
            
            if (roomParam) {
                viewerRoomId.value = decodeURIComponent(roomParam);
                showToast('ğŸ“‹ ØªÙ… ØªØ­Ù…ÙŠÙ„ Ù…Ø¹Ø±Ù Ø§Ù„Ø¨Ø« ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„Ø±Ø§Ø¨Ø·');
                
                // Auto-join after a short delay
                setTimeout(() => {
                    if (!state.isConnected) {
                        joinBtn.click();
                    }
                }, 1000);
            }
        }

        // Join the broadcast
        async function joinBroadcast() {
            try {
                state.currentRoomId = viewerRoomId.value.trim();
                
                if (!state.currentRoomId) {
                    showToast('âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¹Ø±Ù Ø§Ù„Ø¨Ø«', 'error');
                    return;
                }

                updateStatus('Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¨Ø«...', 'connecting');
                joinBtn.disabled = true;
                joinBtn.innerHTML = '<span class="loading"></span><span>Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„...</span>';

                // Start connection timeout
                state.connectionTimeout = setTimeout(() => {
                    if (!state.isConnected) {
                        showToast('âŒ Ø§Ù†ØªÙ‡Ù‰ ÙˆÙ‚Øª Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±. ØªØ­Ù‚Ù‚ Ù…Ù† Ù…Ø¹Ø±Ù Ø§Ù„Ø¨Ø«.', 'error');
                        updateStatus('ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„', 'disconnected');
                        resetConnection();
                    }
                }, CONFIG.CONNECTION_TIMEOUT);

                // Connect to signaling server
                await connectToSignalingServer();

                // Create WebRTC peer connection
                await createPeerConnection();

                // Send join request
                const viewerId = `viewer_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
                state.socket.send(JSON.stringify({
                    type: 'join-room',
                    roomId: state.currentRoomId,
                    viewerId: viewerId,
                    timestamp: Date.now(),
                    quality: state.streamQuality
                }));

                // Show connecting overlay
                videoOverlay.innerHTML = `
                    <div class="overlay-icon">â³</div>
                    <h2 style="margin-bottom: 15px; font-size: 2rem;">Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„...</h2>
                    <p style="color: #a1cae2; max-width: 500px;">
                        Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„ØºØ±ÙØ©: <strong>${state.currentRoomId}</strong>
                    </p>
                    <p style="color: #6c757d; margin-top: 10px;">
                        Ù‚Ø¯ ÙŠØ³ØªØºØ±Ù‚ Ù‡Ø°Ø§ Ø¨Ø¶Ø¹ Ø«ÙˆØ§Ù†ÙŠ
                    </p>
                `;

            } catch (error) {
                console.error('Error joining broadcast:', error);
                showToast(`âŒ ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„: ${error.message}`, 'error');
                updateStatus('ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„', 'disconnected');
                resetConnection();
            }
        }

        // Leave the broadcast
        function leaveBroadcast() {
            if (state.peerConnection) {
                state.peerConnection.close();
                state.peerConnection = null;
            }

            if (state.socket && state.socket.readyState === WebSocket.OPEN) {
                state.socket.send(JSON.stringify({
                    type: 'leave-room',
                    roomId: state.currentRoomId,
                    timestamp: Date.now()
                }));
                state.socket.close();
            }

            if (state.watchInterval) {
                clearInterval(state.watchInterval);
                state.watchInterval = null;
            }

            if (state.connectionTimeout) {
                clearTimeout(state.connectionTimeout);
                state.connectionTimeout = null;
            }

            // Reset state
            state = {
                socket: null,
                peerConnection: null,
                currentRoomId: '',
                isConnected: false,
                reconnectAttempt: 0,
                watchStartTime: null,
                watchInterval: null,
                streamQuality: state.streamQuality,
                volume: state.volume,
                isFullscreen: state.isFullscreen,
                connectionTimeout: null
            };

            // Reset UI
            resetUI();
            
            remoteVideo.srcObject = null;
            videoOverlay.style.display = 'flex';
            videoOverlay.innerHTML = `
                <div class="overlay-icon">ğŸ“º</div>
                <h2 style="margin-bottom: 15px; font-size: 2rem;">ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø¨Ø«</h2>
                <p style="color: #a1cae2; max-width: 500px; margin-bottom: 25px;">
                    Ø£Ø¯Ø®Ù„ Ù…Ø¹Ø±Ù Ø§Ù„Ø¨Ø« ÙÙŠ Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© ÙˆØ§Ù†Ø¶Ù… Ù„Ù…Ø´Ø§Ù‡Ø¯Ø© Ø§Ù„Ø¨Ø« Ø§Ù„Ù…Ø¨Ø§Ø´Ø±
                </p>
            `;
            
            updateStatus('ØºØ§Ø¯Ø±Øª Ø§Ù„Ø¨Ø«', 'disconnected');
            showToast('ğŸ‘‹ ØºØ§Ø¯Ø±Øª Ø§Ù„Ø¨Ø« Ø§Ù„Ù…Ø¨Ø§Ø´Ø±');
        }

        // Connect to signaling server
        function connectToSignalingServer() {
            return new Promise((resolve, reject) => {
                state.socket = new WebSocket(CONFIG.SIGNALING_SERVER);
                
                state.socket.onopen = () => {
                    console.log('âœ… Connected to signaling server');
                    state.reconnectAttempt = 0;
                    resolve();
                };

                state.socket.onmessage = async (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('ğŸ“© Signal:', data.type);
                        
                        switch (data.type) {
                            case 'welcome':
                                console.log('Server welcome:', data.message);
                                break;
                                
                            case 'room-joined':
                                handleRoomJoined(data);
                                break;
                                
                            case 'offer':
                                handleBroadcasterOffer(data);
                                break;
                                
                            case 'answer':
                                handleBroadcasterAnswer(data);
                                break;
                                
                            case 'ice-candidate':
                                handleIceCandidate(data);
                                break;
                                
                            case 'broadcaster-left':
                                handleBroadcasterLeft(data);
                                break;
                                
                            case 'error':
                                showToast(`âŒ ${data.message}`, 'error');
                                resetConnection();
                                break;
                        }
                    } catch (error) {
                        console.error('Error processing message:', error);
                    }
                };

                state.socket.onerror = (error) => {
                    console.error('âŒ WebSocket error:', error);
                    reject(error);
                };

                state.socket.onclose = () => {
                    console.log('ğŸ”Œ WebSocket closed');
                    
                    if (state.isConnected && state.reconnectAttempt < CONFIG.RECONNECT_DELAYS.length) {
                        const delay = CONFIG.RECONNECT_DELAYS[state.reconnectAttempt];
                        state.reconnectAttempt++;
                        
                        console.log(`â™»ï¸ Reconnecting in ${delay}ms (attempt ${state.reconnectAttempt})`);
                        updateStatus(`Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„... (${state.reconnectAttempt})`, 'connecting');
                        
                        setTimeout(() => {
                            connectToSignalingServer().catch(console.error);
                        }, delay);
                    } else if (state.isConnected) {
                        showToast('âŒ ÙÙ‚Ø¯Øª Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±', 'error');
                        updateStatus('ÙÙ‚Ø¯Ø§Ù† Ø§Ù„Ø§ØªØµØ§Ù„', 'disconnected');
                        resetConnection();
                    }
                };
            });
        }

        // Handle room joined
        function handleRoomJoined(data) {
            console.log('âœ… Joined room:', data.roomId);
            updateStatus('Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù…Ø¯ÙŠØ¹...', 'connecting');
            showToast('âœ… Ø§Ù†Ø¶Ù…Ù…Øª Ù„Ù„ØºØ±ÙØ© Ø¨Ù†Ø¬Ø§Ø­');
        }

        // Handle broadcaster offer
        async function handleBroadcasterOffer(data) {
            try {
                console.log('ğŸ“¨ Received offer from broadcaster');
                
                if (!state.peerConnection) {
                    await createPeerConnection();
                }
                
                await state.peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                
                // Create and send answer
                const answer = await state.peerConnection.createAnswer();
                await state.peerConnection.setLocalDescription(answer);
                
                if (state.socket && state.socket.readyState === WebSocket.OPEN) {
                    state.socket.send(JSON.stringify({
                        type: 'answer',
                        answer: answer,
                        roomId: state.currentRoomId,
                        timestamp: Date.now()
                    }));
                }
                
            } catch (error) {
                console.error('Error handling offer:', error);
                showToast('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù…Ø¯ÙŠØ¹', 'error');
            }
        }

        // Handle broadcaster answer
        async function handleBroadcasterAnswer(data) {
            if (state.peerConnection && data.answer) {
                try {
                    await state.peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                } catch (error) {
                    console.error('Error setting remote description:', error);
                }
            }
        }

        // Handle ICE candidate
        function handleIceCandidate(data) {
            if (state.peerConnection && data.candidate) {
                state.peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate))
                    .catch(error => console.error('Error adding ICE candidate:', error));
            }
        }

        // Handle broadcaster left
        function handleBroadcasterLeft(data) {
            showToast('ğŸ“¢ Ø§Ù„Ù…Ø¯ÙŠØ¹ Ø£Ù†Ù‡Ù‰ Ø§Ù„Ø¨Ø«', 'error');
            updateStatus('Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ø¨Ø«', 'disconnected');
            resetConnection();
            
            videoOverlay.style.display = 'flex';
            videoOverlay.innerHTML = `
                <div class="overlay-icon">ğŸ“¢</div>
                <h2 style="margin-bottom: 15px; font-size: 2rem;">Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ø¨Ø«</h2>
                <p style="color: #a1cae2; max-width: 500px; margin-bottom: 25px;">
                    Ø§Ù„Ù…Ø¯ÙŠØ¹ Ø£Ù†Ù‡Ù‰ Ø§Ù„Ø¨Ø« Ø§Ù„Ù…Ø¨Ø§Ø´Ø±. ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ù„Ø¨Ø« Ø¢Ø®Ø±.
                </p>
            `;
        }

        // Create WebRTC peer connection
        async function createPeerConnection() {
            state.peerConnection = new RTCPeerConnection({
                iceServers: CONFIG.STUN_SERVERS,
                iceCandidatePoolSize: 10,
                iceTransportPolicy: 'all'
            });

            // Handle incoming stream
            state.peerConnection.ontrack = (event) => {
                console.log('ğŸ“¹ Received stream:', event.track.kind);
                
                if (remoteVideo.srcObject !== event.streams[0]) {
